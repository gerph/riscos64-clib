#!/bin/env perl
##
# Generate a relocation table which can be used at runtime.
#
# We read in a relocation table generated by objdump --reloc.
# The relocation section looks like this:
#
# ----
# RELOCATION RECORDS FOR [.data.rel]:
# OFFSET           TYPE              VALUE 
# 0000000000000000 R_AARCH64_ABS64   numbers+0x0000000000000008
# 0000000000000008 R_AARCH64_ABS64   func
# 0000000000000010 R_AARCH64_ABS64   func
# ----
#
# Only the .data.rel section is relevant to us.
#
# We also need to know the symbols that will be used, so that
# we know the section that the symbols are in, generated by
# objdump --syms.
# The symbol table looks like this:
#
# ----
# SYMBOL TABLE:
# 0000000000000004 l    d  .text  0000000000000000 .text
# 00000000000072f0 l    d  .data  0000000000000000 .data
# 0000000000007570 l    d  .data.rel      0000000000000000 .data.rel
# 0000000000000000 l    df *ABS*  0000000000000000 module
# 0000000000000001 l       *ABS*  0000000000000000 __riscos64
# 0000000000000001 l       *ABS*  0000000000000000 __riscos
# 0000000000000004 l       .text  0000000000000000 _CMUNGE_origin
# 00000000000000ec l       .text  0000000000000000 _CMUNGE_init
# ----
#
# We create a GNU assembler file, and then we assemble to make an ELF file
# which contains the relocation table.
#
# Syntax: riscos64-mkreloc <relocs> [-s|-o] <output>
#

use strict;
use warnings;

my $relocfile = undef;
my $output = undef;
my $outputtype = 'o';

my $section_symbol = '__DataRelStart';

my @source;
my @tabs = (8, 16, 40);
my $as = $ENV{'AS'} // 'aarch64-unknown-linux-gnu-as';

sub add_output
{
    my $type = shift @_;
    my @lines;
    for my $line (@_)
    {
        if ($line eq '')
        {
            push @lines, '';
            next;
        }

        my $comment = undef;
        my @parts = split /\t/, $line;
        if ($parts[-1] =~ /^(.*)\s+(\/\/.*)/)
        {
            $comment = $2;
            if ($1)
            {
                $parts[-1] = $1
            }
            else
            {
                pop @parts;
            }
        }
        my $l = shift @parts;
        for my $part (@parts)
        {
            my $tab = 0;
            for my $t (@tabs)
            {
                $tab = $t - length($l);
                if ($tab > 0)
                {
                    last;
                }
            }
            if ($tab > 0)
            {
                $l .= ' ' x $tab;
            }
            else
            {
                $l .= ' ';
            }
            $l .= $part;
        }
        if ($comment)
        {
            $l .= ' ' x (40 - length($l)) . $comment;
        }
        push @lines, $l;
    }
    if ($type eq 'end')
    {
        push @source, @lines;
    }
    else
    {
        unshift @source, @lines;
    }
}

sub append_output
{
    add_output('end', @_);
}

sub prepend_output
{
    add_output('start', @_);
}


while (my $arg = shift)
{
    if ($arg =~ /^-/)
    {
        my $switch = $arg;
        if ($switch eq '-s')
        {
            $outputtype = 's';
        }
        elsif ($switch eq '-o')
        {
            $outputtype = 'o';
        }
        else
        {
            print STDERR "Unrecognised switch '$switch'\n";
            exit(1);
        }
    }
    else
    {
        if (!defined $relocfile)
        {
            $relocfile = $arg;
        }
        elsif (!defined $output)
        {
            $output = $arg;
        }
        else
        {
            print STDERR "Unrecognised argument '$arg'\n";
            exit(1);
        }
    }
}

my $inreloc_section;
my $insymbols;

my %symbols;
my $nrelocations = 0;

append_output('.section .rodata',
              '',
              '.balign 4',
#              '.ascii "DREL"',
              '.global __RelocData',
              '__RelocData:',
              '');

open(my $ifh, "<", $relocfile) || die "Cannot read relocation file '$relocfile': $!\n";
while (<$ifh>)
{
    chomp;
    if (/^RELOCATION RECORDS FOR \[(.*)\]:/)
    {
        $inreloc_section = $1;
    }
    elsif ($_ eq '')
    {
        # Blank line, so we're no longer in a relocation section or symbols
        $inreloc_section = undef;
        $insymbols = undef;
    }
    elsif (/^SYMBOL TABLE:/)
    {
        $insymbols = 1;
    }
    elsif ($insymbols)
    {
        # We're in the symbols table. We need to provide a way to identify them from the line.
        # The lines look like:
        #
        # 00000000000021b0 l     F .text  000000000000002c stdout_writen
        # ^                ^     ^ ^      ^                ^
        # value/offset     |     | |      size             name
        #                  |     | section
        #                  |     type (F/O/f)
        #                  scope (l/g)
        if (/^([A-Fa-f0-9]{16})\s+(.*?)\s([_.][a-zA-Z_0-9._-]+|\*ABS\*|\*UND\*)\s+([A-Fa-f0-9]{16})\s+([a-zA-Z_.][^\s]*)$/)

        {
            my $address = hex($1);
            my $flags = $2;
            my $section = $3;
            my $size = hex($4);
            my $name = $5;

            if ($flags =~ /l/)
            {
                # Ignore local symbols
                next;
            }

            $symbols{$name} = {
                    'section' => $section,
                    'function' => (($flags =~ /F/) ? 1 : 0),
                    'data' => (($flags =~ /O/) ? 1 : 0),
                    'file' => (($flags =~ /f/) ? 1 : 0),
                    'global' => (($flags =~ /g/) ? 1 : 0),
                    'address' => $address,
                    'size' => $size,
                    'name' => $name,
                };
        }
        else
        {
            print STDERR "Unrecognised symbol table line: $_\n";
            exit(1);
        }
    }
    elsif ($inreloc_section && $inreloc_section eq '.data.rel')
    {
        # We're in a section we're interested in
        #
        # The type of line we are interested in is:
        #
        # 0000000000000000 R_AARCH64_ABS64   numbers+0x0000000000000008
        if (/^([A-Fa-f0-9]{16}) +(R_[^ ]*) +(.*)$/)
        {
            my $section_offset = hex($1);
            my $reloctype = $2;
            my $value = $3;
            my $valuesym = undef;
            my $valueoffset = 0;
            if ($value =~ /^([a-zA-Z_][a-zA-Z_0-9]*)$/)
            {
                $valuesym = $1;
            }
            elsif ($value =~ /^([a-zA-Z_][a-zA-Z_0-9]*)\+0x([A-Fa-f0-9]{16})$/)
            {
                $valuesym = $1;
                $valueoffset = hex($2);
            }
            else
            {
                print STDERR "Relocation value '$value' not understood in '$_'\n";
                exit(1);
            }
            if ($reloctype ne 'R_AARCH64_ABS64')
            {
                print STDERR "Relocation type '$reloctype' not understood in '$_'\n";
                exit(1);
            }

            my $sym = $symbols{$valuesym};
            if (!defined $sym)
            {
                print STDERR "Cannot locate symbol '$sym' in relocation '$_'\n";
                exit(1);
            }
            my $reloctabletype = undef;
            my $section = $sym->{'section'};
            if ($section =~ /^\.text/)
            {
                $reloctabletype = 1;     # 1 => code area relocation
            }
            elsif ($section =~ /^\.rodata/)
            {
                $reloctabletype = 2;     # 2 => RO data area relocation
            }
            elsif ($section =~ /^\.data/)
            {
                $reloctabletype = 3;     # 3 => RW data area relocation
            }
            else
            {
                print STDERR "Unsupported relocation type for section '$section' in relocation '$_'\n";
                exit(1);
            }

            append_output(".word\t$reloctabletype\t// Patch type (for section $section)",
                          ".dword\t$section_symbol + $section_offset\t// File offset to patch",
                          ".dword\t$valuesym + $valueoffset\t// File offset to point to");
            $nrelocations++;
        }
    }
}

if ($nrelocations > 0)
{
    append_output("",
                  ".word\t0\t// Table terminator");
}
# my $got_size = ($symbols{'__GOTStart'} && $symbols{'__GOTEnd'}) ? ($symbols{'__GOTEnd'}->{'address'} - $symbols{'__GOTStart'}->{'address'}) : 0;
# FIXME: GOT cannot be optimised out because in the partially linked ELF we don't get a GOT region to decide if we need it.
#        Maybe we could make this decision based on whether there are any GOT relocations?
my $got_size = 1;

append_output('.section .text',
              '',
              '.global __RelocCode',
              '.asciz "__RelocCode"',
              '.balign 4',
              '.word 0xFF00000C',
              '__RelocCode:',
              '');

if ($nrelocations == 0 &&
    $got_size == 0)
{
    append_output("\tRET");
}
else
{
    # We have a stack, but we're not going to use it, as we have lots of registers free.
    # We intentionally avoid using x0-x3 so that we can in the future pass parameters on
    # entry (ie avoiding OS_GetEnv).
    # We don't have any data relocations at all - in RISC OS 64, we don't bother with
    # multiple instantiation as it does not fit with how AArch64 code is compiled,
    # and is generally not a useful feature.
    append_output(split("\n", <<EOM ));
        LDR     x4, RelocCodeAddress
        ADR     x5, __RelocCode
        SUBS    x4, x5, x4
        BEQ     reloc_exit              // we're already at the right address.

        ADR     x6, RelocDataAddress
        LDR     x5, [x6]
        ADD     x5, x5, x4              // relocate our linkage table
        STR     x5, [x6]

EOM

    if ($nrelocations > 0)
    {
        # If the relocations table exists, then we can apply it.
        append_output(split("\n", <<EOM ));
reloc_table_loop:
        LDR     w6, [x5], #4            // Read relocation type
        // Actually at the moment we don't use this type except as a terminator
        CMP     w6, #0                  // Check for 'end of list'
        BEQ     reloc_table_done
        LDP     x7, x8, [x5], #16       // read memory and pointer
        ADD     x7, x7, x4
        ADD     x8, x8, x4
        STR     x8, [x7]
        B       reloc_table_loop

reloc_table_done:
EOM
    }


    if ($got_size > 0)
    {
        append_output(split("\n", <<EOM ));
        ADR     x6, GOTStartAddress
        LDP     x5, x9, [x6]
        ADD     x5, x5, x4
        ADD     x9, x9, x4
        STP     x5, x9, [x6]

reloc_got_loop:
        CMP     x5, x9
        BHS     reloc_exit
        LDR     x7, [x5], #8
        CMP     x7, #0
        BEQ     reloc_got_loop
        ADD     x7, x7, x4
        STR     x7, [x5, #-8]
        B       reloc_got_loop
EOM
    }

    append_output(split("\n", <<EOM ));

reloc_exit:
        RET

RelocCodeAddress:
.dword  __RelocCode
RelocDataAddress:
.dword  __RelocData

EOM

    if ($got_size > 0)
    {
        append_output(split("\n", <<EOM ));
GOTStartAddress:
.dword  __GOTStart
GOTEndAddress:
.dword  __GOTEnd

EOM
    }
}

if ($outputtype eq 's')
{
    open(my $ofh, '>', "$output") || die "Cannot create output source '$output'\n";
    print $ofh map { "$_\n" } @source;
    close($ofh);
    exit(0);
}

# We're outputting the relocation table as an ELF file.

# For diagnostics:
#print STDERR map { "$_\n" } @source;

open(my $pipe, "|-", "$as -o $output") || die "Failed to create relocation table object '$output' through GNU assember (cannot find binary?)\n";
print $pipe map { "$_\n" } @source;
close($pipe) || die "Failed to create relocation table object '$output' through GNU assember (cannot assemble?)\n";
