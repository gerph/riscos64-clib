#!/usr/bin/env perl
##
# Generate a relocation table which can be used at runtime.
#
# We read in a relocation table generated by objdump --reloc.
# The relocation section looks like this:
#
# ----
# RELOCATION RECORDS FOR [.data.rel]:
# OFFSET           TYPE              VALUE 
# 0000000000000000 R_AARCH64_ABS64   numbers+0x0000000000000008
# 0000000000000008 R_AARCH64_ABS64   func
# 0000000000000010 R_AARCH64_ABS64   func
# ----
#
# Only the .data.rel.* sections are relevant to us for relocation,
# but there may be other relocations we handle.
#
# We also need to know the symbols that will be used, so that
# we know the section that the symbols are in, generated by
# objdump --syms.
# The symbol table looks like this:
#
# ----
# SYMBOL TABLE:
# 0000000000000004 l    d  .text  0000000000000000 .text
# 00000000000072f0 l    d  .data  0000000000000000 .data
# 0000000000007570 l    d  .data.rel      0000000000000000 .data.rel
# 0000000000000000 l    df *ABS*  0000000000000000 module
# 0000000000000001 l       *ABS*  0000000000000000 __riscos64
# 0000000000000001 l       *ABS*  0000000000000000 __riscos
# 0000000000000004 l       .text  0000000000000000 _CMUNGE_origin
# 00000000000000ec l       .text  0000000000000000 _CMUNGE_init
# ----
#
# We create a GNU assembler file, and then we assemble to make an ELF file
# which contains the relocation table.
#
# The following are the symbols that will be created:
#
#   __RelocCode - This should be called very early in the initialisation of
#                 a binary to relocate the binary for the current execution
#                 location. There are no input parameters, and no stack will
#                 be used. Registers x0-x15 will be corrupted.
#                 A replacement routine may be created which follows the
#                 above rules by creating such a symbol in the ELF to be
#                 linked.
#   __RelocData - This contains the relocation data, held within the
#                 .riscos.reloc section, which will be used to perform the
#                 relocations.
#
# Relocation data has the following repeated format:
#
#   4 bytes     flags       Flags describing the relocation entry:
#                               b0-3:   target data binary region
#                                           1: code region
#                                           2: readonly data region
#                                           3: readwrite data region
#                               b4-7:   unused, must be 0
#                               b8-11:  source data binary region
#                                           1: code region
#                                           2: readonly data region
#                                           3: readwrite data region
#                               b12-15: unused, must be 0
#                               b16:    short relocation entry (offsets
#                                       are 4 bytes long, not 8 bytes).
#                               b17-31: unused, must be 0
#   4/8 bytes   src         Source offset from start of binary, size
#                           controlled by b16.
#   4/8 bytes   dst         Target offset from start of binary, size
#                           controlled by b16.
#
# The table is terminated by a flags value of 0.
#
# The following symbols will be used:
#
#   __CodeStart - contains the address of the start of the .text section.
#   __RODataStart - contains the address of the start of the .rodata section,
#                   and any others with that prefix.
#   __RODataRelStart - contains the address of the start of the .data.rel.ro
#                      section, and any others with that prefix.
#   __DataRelStart - contains the address of the state of the .data.rel
#                    section, and any others with that prefix.
#   __DataStart - contains the start address of the .data section, and any
#                 others with that prefix.
#   __ZIStart - contains the start address of the .bss section, and any
#               others with that prefix.
#
# It is expected (but may not be required) that these symbols be in the
# order given.
#
#
# Syntax: riscos64-mkreloc <relocs> [-s|-o] <output>
#

use strict;
use warnings;

my $relocfile = undef;
my $output = undef;
my $outputtype = 'o';
my $debug = $ENV{'ROBUILD_MKRELOC_DEBUG'} // 0;

my @source;
my @tabs = (8, 16, 40);
my $as = $ENV{'AS'} // 'aarch64-unknown-linux-gnu-as';
my %symbols;

sub add_output
{
    my $type = shift @_;
    my @lines;
    for my $line (@_)
    {
        if ($line eq '')
        {
            push @lines, '';
            next;
        }

        my $comment = undef;
        my @parts = split /\t/, $line;
        if ($parts[-1] =~ /^(.*)\s+(\/\/.*)/)
        {
            $comment = $2;
            if ($1)
            {
                $parts[-1] = $1
            }
            else
            {
                pop @parts;
            }
        }
        my $l = shift @parts;
        for my $part (@parts)
        {
            my $tab = 0;
            for my $t (@tabs)
            {
                $tab = $t - length($l);
                if ($tab > 0)
                {
                    last;
                }
            }
            if ($tab > 0)
            {
                $l .= ' ' x $tab;
            }
            else
            {
                $l .= ' ';
            }
            $l .= $part;
        }
        if ($comment)
        {
            $l .= ' ' x (40 - length($l)) . $comment;
        }
        push @lines, $l;
    }
    if ($type eq 'end')
    {
        push @source, @lines;
    }
    else
    {
        unshift @source, @lines;
    }
}

sub append_output
{
    add_output('end', @_);
}

sub prepend_output
{
    add_output('start', @_);
}


##
# Extract a value from a relocation in the form <symbol/section>+0x<value>
#
# @param    $value = the string to process
#
# @return:  ($section_name, $symbol_relative, $value_offset)
sub extract_value
{
    my ($value) = @_;
    my $valuesym = undef;
    my $valueoffset = 0;
    my $section = '';

    if ($value =~ /^(\.?[a-zA-Z_][a-zA-Z_0-9\.]*)$/)
    {
        $valuesym = $1;
    }
    elsif ($value =~ /^(\.?[a-zA-Z_][a-zA-Z_0-9\.]*)\+0x([A-Fa-f0-9]{16})$/)
    {
        $valuesym = $1;
        $valueoffset = hex($2);
    }
    else
    {
        print STDERR "Relocation value '$value' not understood in '$_'\n";
        exit(1);
    }

    if ($valuesym =~ /^\./)
    {
        # It's already a section
        $section = $valuesym;
        if ($valuesym =~ /^\.text/)
        {
            $valuesym = '__CodeStart';
        }
        elsif ($valuesym =~ /^\.rodata/)
        {
            $valuesym = '__RODataStart';
        }
        elsif ($valuesym =~ /^\.data\.rel\.ro/)
        {
            $valuesym = '__RODataRelStart';
        }
        elsif ($valuesym =~ /^\.data\.rel/)
        {
            $valuesym = '__DataRelStart';
        }
        elsif ($valuesym =~ /^\.data/)
        {
            $valuesym = '__DataStart';
        }
        elsif ($valuesym =~ /^\.bss/)
        {
            $valuesym = '__ZIStart';
        }
    }
    else
    {
        my $sym = $symbols{$valuesym};
        if (!defined $sym)
        {
            print STDERR "Cannot locate symbol '$sym' in relocation '$_'\n";
            exit(1);
        }
        $section = $sym->{'section'};
    }
    return ($section, $valuesym, $valueoffset);
}


##
# Convert the section name into a relocation type
#
# @param    $section = the section we're decoding
#
# @return:  1 for code, 2 for read-only data, 3 for read-write data
sub relocation_type
{
    my ($section) = @_;

    my $reloctabletype = undef;
    if ($section =~ /^\.text/)
    {
        $reloctabletype = 1;     # 1 => code area relocation
    }
    elsif ($section =~ /^\.rodata|^\.data\.rel\.ro/)
    {
        $reloctabletype = 2;     # 2 => RO data area relocation
    }
    elsif ($section =~ /^\.data|^\.bss/)
    {
        $reloctabletype = 3;     # 3 => RW data area relocation
    }
    else
    {
        print STDERR "Unsupported relocation type for section '$section' in relocation '$_'\n";
        exit(1);
    }
    return $reloctabletype;
}


while (my $arg = shift)
{
    if ($arg =~ /^-/)
    {
        my $switch = $arg;
        if ($switch eq '-s')
        {
            $outputtype = 's';
        }
        elsif ($switch eq '-o')
        {
            $outputtype = 'o';
        }
        else
        {
            print STDERR "Unrecognised switch '$switch'\n";
            exit(1);
        }
    }
    else
    {
        if (!defined $relocfile)
        {
            $relocfile = $arg;
        }
        elsif (!defined $output)
        {
            $output = $arg;
        }
        else
        {
            print STDERR "Unrecognised argument '$arg'\n";
            exit(1);
        }
    }
}

if (!defined $relocfile || !defined $output)
{
    die "Syntax: riscos64-mkreloc <symbols> <binary>\n";
}

my $inreloc_section;
my $insymbols;
my $section_symbol;
my $section_reloctabletype;

my $nrelocations = 0;

append_output('.section .riscos.reloc',
              '',
              '.balign 4',
#              '.ascii "DREL"',
              '.global __RelocData',
              '__RelocData:',
              '');

open(my $ifh, "<", $relocfile) || die "Cannot read relocation file '$relocfile': $!\n";
while (<$ifh>)
{
    chomp;
    if (/^RELOCATION RECORDS FOR \[(.*)\]:/)
    {
        $inreloc_section = $1;
        $insymbols = undef;
        if ($inreloc_section =~ /^(\.text|\.rodata|\.data|\.bss)/)
        {
            # One of the relocation sections we can handle
            print "Processing relocations for $inreloc_section\n" if ($debug);
            ($_, $section_symbol, $_) = extract_value($inreloc_section);
            $section_reloctabletype = relocation_type($inreloc_section);
        }
        else
        {
            # We don't handle the relocation records for this section.
            print "Skipping relocations for $inreloc_section\n" if ($debug);
            $inreloc_section = undef;
        }
    }
    elsif ($_ eq '')
    {
        # Blank line, so we're no longer in a relocation section or symbols
        $inreloc_section = undef;
        $insymbols = undef;
    }
    elsif (/^SYMBOL TABLE:/)
    {
        $insymbols = 1;
    }
    elsif ($insymbols)
    {
        # We're in the symbols table. We need to provide a way to identify them from the line.
        # The lines look like:
        #
        # 00000000000021b0 l     F .text  000000000000002c stdout_writen
        # ^                ^     ^ ^      ^                ^
        # value/offset     |     | |      size             name
        #                  |     | section
        #                  |     type (F/O/f)
        #                  scope (l/g)
        if (/^([A-Fa-f0-9]{16})\s+(.*?)\s([_.][a-zA-Z_0-9._-]+|\*ABS\*|\*UND\*)\s+([A-Fa-f0-9]{16})\s+([a-zA-Z_.][^\s]*)$/)
        {
            my $address = hex($1);
            my $flags = $2;
            my $section = $3;
            my $size = hex($4);
            my $name = $5;

            if ($flags =~ /l/)
            {
                # Ignore local symbols
                next;
            }
            if ($section eq '*UND*')
            {
                # Ignore undefined symbols (references that haven't been resolved)
                next;
            }

            $symbols{$name} = {
                    'section' => $section,
                    'function' => (($flags =~ /F/) ? 1 : 0),
                    'data' => (($flags =~ /O/) ? 1 : 0),
                    'file' => (($flags =~ /f/) ? 1 : 0),
                    'global' => (($flags =~ /g/) ? 1 : 0),
                    'address' => $address,
                    'size' => $size,
                    'name' => $name,
                };
        }
        elsif (/^([A-Fa-f0-9]{16})\s+(.*?)\s(\*UND\*)\s+([A-Fa-f0-9]{16})\s*$/)
        {
            # Empty UND appears sometimes in our output. Not clear why, but we ignore.
        }
        else
        {
            print STDERR "Unrecognised symbol table line: $_\n";
            exit(1);
        }
    }
    elsif ($inreloc_section && $inreloc_section =~ /^\.data.*|\.rodata.*/)
    {
        # We're in a section we're interested in relocating.
        #
        # The type of line we are interested in is:
        #
        # 0000000000000000 R_AARCH64_ABS64   numbers+0x0000000000000008
        if (/^([A-Fa-f0-9]{16}) +(R_[^ ]*) +(.*)$/)
        {
            my $section_offset = hex($1);
            my $reloctype = $2;
            my $value = $3;
            my ($valuesection, $valuesym, $valueoffset) = extract_value($value);

            if ($reloctype ne 'R_AARCH64_ABS64')
            {
                print STDERR "Relocation type '$reloctype' not understood in '$_'\n";
                exit(1);
            }

            my $value_reloctabletype = relocation_type($valuesection);

            my $expected_source = $symbols{$section_symbol}->{'address'} + $section_offset;
            my $expected_target = $symbols{$valuesym}->{'address'} + $valueoffset;
            my $limit = (1<<28);  # This ensures that the table is mostly 32bit values.
            if ($expected_source < $limit && $expected_target < $limit)
            {
                # Use the compact format
                append_output(".word\t($section_reloctabletype << 8) | ($value_reloctabletype) | (1<<16)\t// Patch type (for section $inreloc_section -> $valuesection, compact representation)",
                              ".word\t$section_symbol + $section_offset\t// File offset to patch",
                              ".word\t$valuesym + $valueoffset\t// File offset to point to");
            }
            else
            {
                append_output(".word\t($section_reloctabletype << 8) | ($value_reloctabletype)\t// Patch type (for section $inreloc_section -> $valuesection)",
                              ".dword\t$section_symbol + $section_offset\t// File offset to patch",
                              ".dword\t$valuesym + $valueoffset\t// File offset to point to");
            }
            $nrelocations++;
        }
    }
}

if ($nrelocations > 0)
{
    append_output("",
                  ".word\t0\t// Table terminator");
}
# my $got_size = ($symbols{'__GOTStart'} && $symbols{'__GOTEnd'}) ? ($symbols{'__GOTEnd'}->{'address'} - $symbols{'__GOTStart'}->{'address'}) : 0;
# FIXME: GOT cannot be optimised out because in the partially linked ELF we don't get a GOT region to decide if we need it.
#        Maybe we could make this decision based on whether there are any GOT relocations?
my $got_size = 1;

if (!defined $symbols{'__RelocCode'})
{
    # If the __RelocCode symbol already exists, we let it be the relocation code.
    # If it does not exists, this is the relocation code we will use...
    append_output('.section .text',
                  '',
                  '.global __RelocCode',
                  '.asciz "__RelocCode"',
                  '.balign 4',
                  '.word 0xFF00000C',
                  '__RelocCode:',
                  '');

    if ($nrelocations == 0 &&
        $got_size == 0)
    {
        append_output("\tRET");
    }
    else
    {
        # We have a stack, but we're not going to use it, as we have lots of registers free.
        # We intentionally avoid using x0-x3 so that we can in the future pass parameters on
        # entry (ie avoiding OS_GetEnv).
        # We don't have any data relocations at all - in RISC OS 64, we don't bother with
        # multiple instantiation as it does not fit with how AArch64 code is compiled,
        # and is generally not a useful feature.
        append_output(split("\n", <<EOM ));
        ADR     x6, RelocCodeAddress
        LDR     x4, [x6]                // Where we /were/ located
        ADR     x5, __RelocCode         // where we /are/ located
        SUBS    x4, x5, x4              // difference in locations
        BEQ     reloc_exit              // we're already at the right address.
        STR     x5, [x6]

        ADR     x6, RelocDataAddress    // (apply this to the relocation data)
        LDR     x5, [x6]
        ADD     x5, x5, x4              // relocate our linkage table
        STR     x5, [x6]

EOM

        if ($nrelocations > 0)
        {
            # If the relocations table exists, then we can apply it.
            append_output(split("\n", <<EOM ));
reloc_table_loop:
        LDR     w6, [x5], #4            // Read relocation type
        // Actually at the moment we don't use this type except as a terminator
        CMP     w6, #0                  // Check for 'end of list'
        BEQ     reloc_table_done
        TBZ     w6, #16, reloc_table_full
        LDP     w7, w8, [x5], #8        // read memory and pointer (compact form)
        B       reloc_table_loaded
reloc_table_full:
        LDP     x7, x8, [x5], #16       // read memory and pointer (64bit form)
reloc_table_loaded:
        ADD     x7, x7, x4
        ADD     x8, x8, x4
        STR     x8, [x7]
        B       reloc_table_loop

reloc_table_done:
EOM
        }


        if ($got_size > 0)
        {
            append_output(split("\n", <<EOM ));
        ADR     x6, GOTStartAddress
        LDP     x5, x9, [x6]            // x5-> global object table start; x9-> GOT end
        ADD     x5, x5, x4
        ADD     x9, x9, x4
        STP     x5, x9, [x6]

reloc_got_loop:
        CMP     x5, x9
        BHS     reloc_exit
        LDR     x7, [x5], #8
        CMP     x7, #0
        BEQ     reloc_got_loop
        ADD     x7, x7, x4
        STR     x7, [x5, #-8]
        B       reloc_got_loop
EOM
        }

        append_output(split("\n", <<EOM ));

reloc_exit:
        RET

RelocCodeAddress:
.dword  __RelocCode
RelocDataAddress:
.dword  __RelocData

EOM

        if ($got_size > 0)
        {
            append_output(split("\n", <<EOM ));
GOTStartAddress:
.dword  __GOTStart
GOTEndAddress:
.dword  __GOTEnd

EOM
        }
    }
}

if ($outputtype eq 's')
{
    open(my $ofh, '>', "$output") || die "Cannot create output source '$output'\n";
    print $ofh map { "$_\n" } @source;
    close($ofh);
    exit(0);
}

# We're outputting the relocation table as an ELF file.

# For diagnostics:
if ($debug)
{
    print STDERR map { "$_\n" } @source;
}

open(my $pipe, "|-", "$as -o $output") || die "Failed to create relocation table object '$output' through GNU assember (cannot find binary?)\n";
print $pipe map { "$_\n" } @source;
close($pipe) || die "Failed to create relocation table object '$output' through GNU assember (cannot assemble?)\n";
